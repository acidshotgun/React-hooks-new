# useMemo

- [ ] `useMemo` — это React Hook, который позволяет кэшировать результат вычислений `между повторными рендерингами`.

<hr>
<br>
<br>

<h2>Основы: рендер компонентов</h2>

- [ ] Вспомним процесс рендера компонентов.

  + Сначала `react render` возвращает `Virtual DOM`.
  + Затем React на основе `Virtual DOM` отрисовывает `DOM`.

  ![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/39da32cd-a8de-4c1c-a880-b23ae45d757e)

  <hr>
  <br>

  + Действие, которое вызывает `setState` - вызывает смену состояния компонента.
  + Несмотря на то, что стояние можно передавать в опр. компоненты - React вызовет перерисовку всего дерева компонентов (+дочерние).
  + На основании в разнице сежду прошлым `Virtual DOM` и актуальным `Virtual DOM` - React внесет точечные изменения в `DOM`
     
    + [x] ПРИМ. это поведение - нормально и в большинстве случаев эта операция протекает очень быстро, тк `Render` - это легковесная операция и не требует больших затрат ресурсов. (Сам код это просто)
    + [x] ПРИМ2. гораздо более сложная операция - это внесение изменений в `DOM`.
   
  <br>
  <br>
  
  - [ ]  По этим причинам логики перерисовки деревьев достаточно и такое поведение - это хорошо. Потому что `React` не должен определять, где и какие изменения нужны => он просто перерисовывает все дерево.
     
  ![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/1d8904e0-fe8b-496d-a701-d5d032b85ba7)

<hr>
<br>
<br>

<h2>Поблемы и решения</h2>

- [ ] Частый вызов `setState` на высоком уровне в дереве компонентов.

  + Это вызовет ререндер всех дочерних компонентов в том числе.
  + Сложные вычисления срабатывают каждый ререндер. 
  + Наличие сложных вычислений внутри дочерних компонентов вызывают просадки по оптимизации.

<br>

- [x] Для решения проблем с оптимизацией, вызваных частым вызовом `setState` внутри компонентов - есть решения:

  + Мемоизация вычислений в рендере.
  + Мемоизация компонентов.
     
![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/677bfaff-dd3f-427d-a5bf-b4b6db444625)

<hr>
<br>
<br>

<h2>Мемоизация вычислений - useMemo()</h2>

- [x] Мемоизация - основной механизм оптимизации в React, начиная с работы с состоянием и заканчивая ререндеров.

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/7f2ffefc-e56a-4ef8-85b5-4773e8917a24)

<br>
<br>
<br>

<hr>

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/b3fd1949-e15e-412e-8a5c-a330ebb86e2e)

<hr>

<br>

- [ ] Обернули вычисления в хук `useMemo()`:

  + Ререндеры происходят как и происходили при смене стейта.
  + Вычисления производятся только в случае изменения зависимостей.
  + Без изменения зависимостей результаты вычислений будут браться из кэша.
  + + разделили вычисления на два `useMemo` тк зависимости могут меняться отдельно. => доп. мини - оптимизация :)
  + Компонент может вызываться множество раз. Но перерасчет будет происходить только при изменении данных.

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/9678e3bf-e80a-4799-879a-dc979c0d2699)

<hr>
<br>
<br>

<h2>Примеры</h2>

[ПРИМЕР С ТУДУШКОЙ](https://codesandbox.io/p/sandbox/todo-memo-392yxx?file=%2Fsrc%2FTodoList.js%3A14%2C12) комментарии:

  + Дефолтный вар - при смене темы - вычисления происходят каждый ререндер, что стопит приложение (у фильтра задержка 500мс).
  + Оборачиваем вычисление для `visibleTodos` в `useMemo()` => при смене темы юзыем кэшированное зн-е.
  + Если убрать `useMemo()` и убрать задержку у фильтров => разницы не будет. Пример когда `useMemo()` не нужен.

