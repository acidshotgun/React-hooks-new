# useMemo

- [ ] `useMemo` — это React Hook, который позволяет кэшировать результат вычислений `между повторными рендерингами`.

<hr>
<br>
<br>

<h2>Основы: рендер компонентов</h2>

- [ ] Вспомним процесс рендера компонентов.

  + Сначала `react render` возвращает `Virtual DOM`.
  + Затем React на основе `Virtual DOM` отрисовывает `DOM`.

  ![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/39da32cd-a8de-4c1c-a880-b23ae45d757e)

  <hr>
  <br>

  + Действие, которое вызывает `setState` - вызывает смену состояния компонента.
  + Несмотря на то, что стояние можно передавать в опр. компоненты - React вызовет перерисовку всего дерева компонентов (+дочерние).
  + На основании в разнице сежду прошлым `Virtual DOM` и актуальным `Virtual DOM` - React внесет точечные изменения в `DOM`
     
    + [x] ПРИМ. это поведение - нормально и в большинстве случаев эта операция протекает очень быстро, тк `Render` - это легковесная операция и не требует больших затрат ресурсов. (Сам код это просто)
    + [x] ПРИМ2. гораздо более сложная операция - это внесение изменений в `DOM`.
   
  <br>
  <br>
  
  - [ ]  По этим причинам логики перерисовки деревьев достаточно и такое поведение - это хорошо. Потому что `React` не должен определять, где и какие изменения нужны => он просто перерисовывает все дерево.
     
  ![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/1d8904e0-fe8b-496d-a701-d5d032b85ba7)

<hr>
<br>
<br>

<h2>Поблемы и решения</h2>

- [ ] Частый вызов `setState` на высоком уровне в дереве компонентов.

  + Это вызовет ререндер всех дочерних компонентов в том числе.
  + Сложные вычисления срабатывают каждый ререндер. 
  + Наличие сложных вычислений внутри дочерних компонентов вызывают просадки по оптимизации.

<br>

- [x] Для решения проблем с оптимизацией, вызваных частым вызовом `setState` внутри компонентов - есть решения:

  + Мемоизация вычислений в рендере.
  + Мемоизация компонентов.
     
![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/677bfaff-dd3f-427d-a5bf-b4b6db444625)

<hr>
<br>
<br>

<h2>Мемоизация вычислений - useMemo()</h2>

- [x] Мемоизация - основной механизм оптимизации в React, начиная с работы с состоянием и заканчивая ререндеров.

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/7f2ffefc-e56a-4ef8-85b5-4773e8917a24)

<br>
<br>
<br>

<hr>

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/b3fd1949-e15e-412e-8a5c-a330ebb86e2e)

+ **``Parameters``**

  - [ ] **`calculateValue`**: - функция, вычисляющая значение, которое вы хотите кэшировать. Она должен быть чистыой, не принимать аргументов и возвращать значение любого типа. React вызовет вашу функцию во время `первоначального рендеринга`. При следующем рендеринге React `снова вернет то же значение`, если `dependencies` `не изменилось с момента последнего рендеринга`. В противном случае он вызовет `calculateValue`, `вернет результат и сохранит его`, чтобы его можно было повторно использовать позже.
  
  - [ ] **`dependencies`**: Список всех реактивных значений, на которые ссылается код `calculateValue`. К реактивным значениям относятся `пропсы`, `состояние`, а также `все переменные и функции`, объявленные непосредственно в теле компонента. Список зависимостей должен содержать `постоянное количество элементов` и быть написан inline, как `[dep1, dep2, dep3]`. React будет сравнивать каждую зависимость с предыдущим значением с помощью сравнения `Object.is`.
 
<br>

+ **``Returns``**

  - [ ] При первом рендере `useMemo` возвращает результат вызова `calculateValue` без аргументов.
  - [ ] При последующих рендерах он либо вернет уже сохраненное значение из последнего рендера (если зависимости не изменились), либо снова вызовет `calculateValue` и вернет результат, который вернул `calculateValue`.

<br>

+ **``WARNING``**

  - [ ] `UseMemo` - это хук, поэтому вы можете вызывать его `только на верхнем уровне вашего компонента` или `ваших собственных хуков`. Вы не можете вызывать его внутри циклов или условий. Если вам это нужно, создайте новый компонент и переместите состояние в него.
  - [ ] В `use strict` - для разработчиков вызывается дважды - эток ок! Один результат будет проигнорирован.
  - [ ] 

<hr>

<br>

- [ ] Обернули вычисления в хук `useMemo()`:

  + Ререндеры происходят как и происходили при смене стейта.
  + Вычисления производятся только в случае изменения зависимостей.
  + Без изменения зависимостей результаты вычислений будут браться из кэша.
  + + разделили вычисления на два `useMemo` тк зависимости могут меняться отдельно. => доп. мини - оптимизация :)
  + Компонент может вызываться множество раз. Но перерасчет будет происходить только при изменении данных.

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/9678e3bf-e80a-4799-879a-dc979c0d2699)

<hr>
<br>
<br>

<h2>Примеры</h2>

[ПРИМЕР С ТУДУШКОЙ](https://codesandbox.io/p/sandbox/todo-memo-392yxx?file=%2Fsrc%2FTodoList.js%3A14%2C12) комментарии:

  + Дефолтный вар - при смене темы - вычисления происходят каждый ререндер, что стопит приложение (у фильтра задержка 500мс).
  + Оборачиваем вычисление для `visibleTodos` в `useMemo()` => при смене темы юзыем кэшированное зн-е.
  + Если убрать `useMemo()` и убрать задержку у фильтров => разницы не будет. Пример когда `useMemo()` не нужен.

