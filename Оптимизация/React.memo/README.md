# React.memo

- [ ] **`React.memo`** - Это `компонент высшего порядка (HOC)` - позволяет пропустить `повторный рендеринг компонента`, если его пропсы `не изменись`.

<br>

+ Это отличает его от обычного компонента, который перерисовывается всегда, когда перерисовывается родительский компонент.

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/85917791-0e11-4e14-ad55-30240865c5a8)

<br>

- [x] Суть:

  + Мы имеем родительский компонент, который может часто производить ререндер.
  + Этот компонент имеет дочерние компоненты, которые будут ререндерится вместе с ним.
  + Если вниз передаются пропсы и они меняются то ок. Но что если пропсы не меняются? Зачем тогда вызывать доп рендеры для дочерних компонентов?

  <br>

  + В этом случае мы можем обернуть эти дочерние компоненты в `React.memo`.
  + Эти компоненты будут ререндерится `ТОЛЬКО` когда `меняются передающиеся в них пропсы`.

<hr>
<br>
<br>

<h2>Использование React.memo</h2>

- [ ] `React.memo` - принимает компонент и возвращает модифицированную версию компонента.

- [ ] `React.memo` - можно использовать двумя способоами.

<br>

  + С использованием дефолтного алгоритма сравнения. (работает по умолчанию).
  + Обычно его достаточно и работает он превосходно.
    
  ```typescript
    const UserCard = memo(({ name, email, phone, avatar }) => {
      return (
        <div clasName="user-card">
          <img src={avatar} alt={name} />
          <h2>{name}</h2>
          <p>{email}</p>
          <p>{phone}</p>
        </div>
      );
    });
  ```

  <br>

  + С использованием кастомного (своего) алгоритма сравнения.
     
  ```typescript
    const areEqual = (prevProps, nextProps) => {
      // Сравнение пропсов
    }
    
    const UserCard = memo(({ name, email, phone, avatar }) => {
      return (
        <div clasName="user-card">
          <img src={avatar} alt={name} />
          <h2>{name}</h2>
          <p>{email}</p>
          <p>{phone}</p>
        </div>
      );
    }, areEqual);
  ```

<hr>
<br>
<br>

<h2>Примеры</h2>

[ПРИМЕР МЕМОИЗАЦИИ КОМПОНЕНТОВ](https://codesandbox.io/p/sandbox/react-memo-pjjgs6?file=%2Fsrc%2FComponent.tsx%3A14%2C2)

  + Компонент `Component` мемоизирован и следит за пропсом `componentCounter`(это в стейте лежит в App).
  + Ререндерится компонент `Component` будет только в том случае, если изменяется состояние `componentCounter`
  + Если изменяется состояние `counter` в App - то только `App`, и `User` произведут ререндер.
  + Если изменяется состояние `componentCounter` в App - то всё, в том числе и `Component` произведет ререндер.

  <br>

  - [ ] Итог:

    + Состояние `counter` меняется - ререндер только `App` и `User`
    + Состояние `componentCounter` меняется - ререндер только всего, в том числе и `Component`, тк он следит за этим состоянием.

<hr>
<br>
<br>

<h2>Минимизация изменений пропсов </h2>

- [x] Когда вы используете `memo`, ваш компонент перерисовывается всякий раз, когда какой-либо реквизит неглубоко равен тому, что было раньше.
- [ ] Это означает, что `React` сравнивает каждый реквизит в вашем компоненте с его предыдущим значением с помощью сравнения `Object.is`. Обратите внимание, что `Object.is(3, 3) - true`, а `Object.is({}, {}) - false`.
- [ ] Аналогично происходит для функций, которые пересоздаются каждый раз заново.
- [ ] ЕЩЕ. Происходит поверхностное сравнение объектов, которые не равны друг-другу ==> если не равны будет ререндер.

<br>

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/63d1fccc-baea-4382-b11d-43b27b2ed601)

<br>

<h3>Решение с useMemo</h3>

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/522a7cf2-6731-467b-8630-59fc35ade7ce)

- [ ] Если дочерний компонент, обернутый в `memo`, будет следить за объектом / массивом, которые выступают в качестве пропса => `memo` так же не будет работать.
- [ ]  Чтобы извлечь максимальную пользу из `memo`, минимизируйте время изменения реквизита. Например, если реквизит является объектом, запретите родительскому компоненту каждый раз заново создавать этот объект с помощью `useMemo`:

  [РЕШЕНИЕ С useMemo](https://codesandbox.io/p/sandbox/react-memo-troubles-nq65wl?file=%2Fsrc%2FApp.tsx)

  + В примере вместо объекта в дочерний компонент мы передаем `мемоизированное вычисление` в которое поместили объект в `useMemo`.
  + Либо дочерник компонентам отдаем пропсы по отдельности (не как объект).
     
<br>

<h3>Решение с useCallback</h3>

![image](https://github.com/acidshotgun/react-hooks-new/assets/117285472/8f284141-30e3-4f9e-a183-bd69d75e4089)


- [ ] Если дочерний компонент, обернутый в `memo`, будет следить за ф-ей, которая выступает в качестве пропса => `memo` так же не будет работать.
- [ ] Причина => функция пересоздается, по принципу - новая ссылка не равна предыдущей.

  [РЕШЕНИЕ С useCallback](https://codesandbox.io/p/sandbox/react-memo-trouble-callback-yw2cjs?file=%2Fsrc%2FApp.tsx%3A15%2C18)

  + В примере в качестве пропса передается ф-я в дочерний компонент `MyComponent`, что приводит к ее пересозданию при изменении стейта `toggle`.
  + Пересоздание приводит к изменению пропса => дочерний компонент ререндерится
  + Оборачивая в `useCallback` ф-ю, она не будет пересоздана, если зависимости не изменяются `(тут это toggle)` 
